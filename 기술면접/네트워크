OSI 7계층을 설명하세요.
- 컴퓨터 사이에서 통신할 때 표준 프로토콜을 사용할 수 있도록 ISO에서 개발한 모델입니다. 물리, 데이터링크, 네트워크, 전송, 세션, 표현, 응용 계층으로 구성되어 있습니다.

7계층으로 나눈 이유는 통신이 일어나는 과정을 단계별로 알 수 있고, 이상이 생기면 해당 계층만 수정할 수 있기 때문입니다.

 

 

라우팅 알고리즘에 대해 설명하세요.
- 라우팅 알고리즘이란 통신할 때 최적의 경로를 찾아 데이터를 전송하는 알고리즘입니다. 이를 위해 능동적으로 라우팅을 수행하는 장비인 라우터가 사용됩니다.

대표적인 라우팅 알고리즘으로는 다익스트라 알고리즘과 벨만포드 알고리즘이 있습니다. 다익스트라 알고리즘은 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택하는 알고리즘이고, 벨만포드 알고리즘은 매번 모든 노드를 확인하면서 거리가 가장 짧은 노드를 선택하는 알고리즘입니다.

 

 

라우터와 스위치의 차이에 대해 설명하세요.
- 라우터는 다양한 네트워크를 연결하는 장치로 IP주소가 사용되고 네트워크 계층에 속합니다. 스위치는 다양한 장치를 동시에 연결하는 장치로 MAC 주소가 사용되고 데이터 링크 계층에 속합니다. 라우터는 목적지가 불명확한 데이터가 들어오면 데이터를 폐기하지만, 스위치는 브로드캐스팅을 한다는 차이점도 있습니다.

 

 

TCP를 설명하세요.
- 전송 계층의 대표적인 프로토콜로 송신 측과 수신 측이 서로 연결을 확인한 뒤 통신하는 연결형 프로토콜입니다. 데이터 전송 중 데이터가 유실되면 재전송을 요청함으로써 신뢰성을 보장합니다.

송신 측과 수신 측이 연결을 확인할 때는 3-way handshaking, 연결을 끊을 때는 4-way handshaking을 합니다.

 

 

TCP 흐름 제어와 혼잡 제어를 설명하세요.
- 흐름 제어 방법으로는 Stop and wait과 Sliding window가 있습니다. Stop and wait은 데이터 전송 후 매번 ACK을 통해 잘 도착했음을 확인하고 다음 데이터를 보내는 방식입니다. Sliding window는 버퍼가 사용되어서 window크기만큼 ACK 없이 데이터를 보낼 수 있는 방식입니다.

혼잡 제어 방법으로는 Stop and Wait ARQ, Go-Back-N ARQ, Selective-Repeat ARQ가 있습니다. Stop and wait ARQ는 수신 측에서 NACK을 전송하거나 주어진 시간 안에 수신 측에서 ACK을 보내지 않으면 송신 측에서 데이터를 재전송하는 방식입니다. Go back N ARQ는 송신 측에서 데이터를 순차적으로 보내면 수신 측에서 지금까지 받은 데이터에 대한 ACK을 한 번만 보내는 방식입니다. 만약 NACK을 받으면 이전에 보낸 데이터들을 모두 다시 보냅니다. Selective repeat ARQ는 Go back N ARQ와 비슷하지만 NACK을 받은 데이터만 다시 보낸다는 차이점이 있습니다.

 

 

TCP 헤더를 설명하세요.
- 송신 측과 수신 측의 포트번호, 연결 정보가 기록된 제어 비트, 오류를 검출할 때 사용되는 체크섬, 몇 번째 데이터인지 알려주는 시퀀스 번호, 몇 번째 데이터까지 수신했는지 알려주는 ACK번호, 윈도우 크기 등이 헤더에 저장되어 있습니다.

 

 

3-way handshaking을 설명하세요.
- 데이터를 전송하기 전, 두 컴퓨터 사이를 연결하는 과정으로 제어 비트 중 SYN, ACK이 사용됩니다. 먼저 클라이언트 쪽에서 SYN이 담긴 데이터를 보내 연결 요청을 합니다. 서버에서 연결을 할 수 있다면 SYN과 ACK이 담긴 데이터를 보냅니다. 이 데이터를 받은 클라이언트 쪽에서 ACK이 담긴 데이터를 보내면 두 컴퓨터 사이의 연결이 완료됩니다.

 

 

4-way handshaking을 설명하세요.
- 데이터 전송이 끝난 뒤, 두 컴퓨터 사이의 연결을 끊기 위한 과정으로 제어 비트의 FIN과 ACK이 사용됩니다. 클라이언트가 연결 종료를 요청하는 의미로 FIN이 담긴 데이터를 보냅니다. 이를 받은 서버는 FIN에 대한 응답으로 ACK이 담긴 데이터를 보냅니다. 이후 서버에서도 FIN이 담긴 데이터를 보내고 이에 대한 응답으로 클라이언트에서 ACK이 담긴 데이터를 보내면 두 컴퓨터 사이의 연결이 종료됩니다.

 

 

UDP를 설명하세요.
- 전송 계층의 프로토콜로 수신 측과 송신 측의 연결을 확인하지 않고 전송하는 비연결형 프로토콜입니다. 데이터가 빠르게 전송되는 효율성은 보장되지만 신뢰성과 정확성은 보장되지 않는다는 특징이 있습니다. 이러한 특징 때문에 실시간 방송처럼 빠른 전송이 필요한 경우에 많이 사용됩니다.

 

 

TCP와 UDP의 차이점에 대해 설명하세요.
- 같은 전송 계층 프로토콜이지만 TCP은 연결형 프로토콜이고 UDP은 비연결형 프로토콜입니다. TCP는 ACK을 통해서 데이터의 수신 여부를 확인하여 신뢰성이 높은 프로토콜이지만 그만큼 속도가 느리다는 특징이 있습니다. 반면 UDP는 수신 여부를 확인하지 않아 속도가 빠르지만 신뢰성이 낮다는 특징이 있습니다.

 

 

HTTP를 설명하세요.
- HTTP는 웹 브라우저와 웹 서버 사이에서 HTML 문서를 전송하기 위해 사용되는 프로토콜입니다. 웹 브라우저가 요청을 하면 웹 서버는 요청에 대한 응답을 하며, HTTP 통신은 반드시 웹 브라우저의 요청이 있어야 통신이 이루어진다는 특징이 있습니다.

 

 

HTTP 메소드의 종류와 역할에 대해 설명하세요.
- HTTP 메소드는 GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS로 총 7개가 있습니다.

GET은 데이터 조회, POST는 데이터를 생성, PUT은 데이터 수정, DELETE은 데이터 삭제할 때 사용합니다. HEAD는 서버가 정상적으로 작동되고 있는지 확인할 때 사용하고, CONNECT은 프록시 서버를 경유하여 SSL 통신을 할 때 사용하며, OPTIONS은 서버가 지원하는 메서드를 확인할 때 사용합니다.

 

 

GET과 POST의 차이를 설명하세요.
- GET은 데이터를 조회할 때 사용하는 메소드로 데이터를 파라미터를 통해 전송하기 때문에 HTTP 요청 메시지의 BODY부분이 비어있습니다. 반면 POST는 데이터를 생성할 때 사용하는 메소드로 데이터 전송 시 HTTP 요청 메시지의 BODY부분에 데이터를 저장하여 전송합니다.

 

 

HTTP 1.0과 1.1의 차이에 대해 설명하세요.
- 먼저 HTTP 1.0은 메서드의 종류가 3가지뿐이고, HTTP 1.1부터는 메서드의 종류가 7가지입니다.

가장 큰 차이점은 HTTP 1.0은 하나의 요청을 보내면 요청에 대한 응답이 돌아올 때까지 기다려야 했지만, HTTP 1.1은 파이프라이닝이 추가되어서 앞에 보냈던 요청에 대한 응답을 기다리지 않고 계속 요청을 보낼 수 있다는 특징이 있습니다.

 

 

HTTPS에 대해 설명하세요.
- HTTP보다 보안이 강화된 프로토콜로 SSL 프로토콜과 함께 동작하는 프로토콜입니다. 데이터가 암호화되지 않아 유출될 경우 보안상의 문제가 발생하는 HTTP와는 달리 HTTPS는 SSL 프로토콜을 통해 암호화함으로써 안전하게 데이터를 전송할 수 있습니다.

 

 

HTTPS가 동작하는 방식에 대해 설명하세요.
- 먼저 HTTP 통신 전에 SSL 핸드쉐이크를 통해 대칭키를 생성합니다.

SSL 핸드쉐이크에 대해 설명한다면 클라이언트가 먼저 자신의 브라우저가 지원하는 암호화 방식들과 랜덤 데이터를 생성하여 전송합니다. 이후 서버는 암호화 방식 중 하나를 선택한 뒤 자신의 공개키가 담긴 인증서와 랜덤 데이터를 생성하여 전송합니다. 클라이언트는 서버가 보낸 인증서를 통해 통신하기에 안전한지 확인하고, 자신의 랜덤 데이터와 서버가 보내준 랜덤 데이터를 하나씩 선택하여 Pre master secret 키를 생성합니다. 이후 클라이언트는 인증서에 담긴 공개키를 통해 Pre master secret 키를 암호화하여 서버에 전송하고, 서버는 자신의 개인키로 Pre master secret를 복호화합니다. 이를 통해 클라이언트와 서버 모두 pre master secret 키를 가지게 되며, 이 키를 통해 master secret 키를 생성하고 session 키를 생성합니다.

이 session 키가 서버와 클라이언트가 데이터를 주고받을 때 사용하는 대칭키가 되며, session 키를 통해 암호화 및 복호화하여 통신을 합니다.

 

 

쿠키와 세션에 대해 설명하세요.
- 쿠키는 사용자 인증에 필요한 정보를 클라이언트에 저장하는 방식이고, 세션은 사용자 인증에 필요한 정보가 서버에 저장되는 방식입니다. 사용자 정보가 서버에 저장되는 세션이 보안적인 측면에서는 더 우수하지만, 속도적인 측면에서는 서버에서 추가적인 처리가 필요한 세션보다 쿠키가 더 빠릅니다. 

 

 

DNS에 대해 설명하세요.
- 사람이 기억하기 쉽게 문자로 만들어진 도메인을 숫자로 된 IP주소로 바꿔주는 시스템을 DNS라고 합니다. IP주소와 도메인이 저장되어 있는 DNS 서버를 이용하여 IP주소를 알 수 있습니다.

 

 

도메인 이름(ex. www.naver.com)으로 실제 IP주소를 어떻게 찾는지에 대해 설명하세요.
- 도메인 이름을 입력하면 먼저 캐시 저장소에서 해당되는 IP주소가 있는지 찾아봅니다. 있다면 바로 IP주소로 접근하고, 없다면 최상위 루트 네임 서버부터 방문합니다. 만약 'www.google.com'을 입력했다면 루트 네임 서버에서는 'com'을 관리하는 네임 서버의 IP주소를 반환합니다. 'com' 네임 서버에서는 'google.com'을 관리하는 IP주소를 반환하고, 'google.com'을 관리하는 네임 서버에 도착하면 'www.google.com'에 대한 IP주소를 알려줍니다. 그 IP주소를 받은 DNS 서버는 요청한 컴퓨터에 IP주소를 반환합니다.

 

 

TCP/IP 4계층에 대해 계층별로 설명하세요.
- TCP/IP 4계층은 OSI 7계층을 단순화한 모델로 네트워크 액세스 계층, 인터넷 계층, 전송 계층, 응용 계층으로 이루어져 있습니다. 네트워크 액세스 계층은 물리적으로 데이터가 어떻게 전송되는 지를 정의한 계층입니다. 인터넷 계층은 IP 주소를 사용하고 라우팅을 통해 데이터를 목적지까지 정확하게 전달합니다. 전송 계층은 패킷의 오류를 검사하고 재전송을 요구하는 등 통신 노드 간의 전반적인 제어를 담당합니다. 응용계층은 사용자로부터 데이터를 입력받고 처리된 데이터를 보여주는 사용자 응용프로그램 인터페이스 계층입니다.

 

 

웹 서버와 웹 어플리케이션 서버에 대해 차이를 중점으로 설명하세요.
- 웹 서버는 HTTP 요청을 받아 정적인 웹 페이지 형태로 응답을 처리해 반환하는 프로그램입니다. 반면 웹 어플리케이션 서버는 사용자 요구사항에 맞는 다양한 로직을 처리하여 동적 컨텐츠를 제공하는 역할을 합니다. 처리 속도를 위해 정적인 처리는 웹 서버를 통해 하고, 동적인 처리는 웹 어플리케이션 서버가 담당합니다.

 

 

"www.naver.com" 또는 "www.google.com"에 접속할 때 일어나는 일에 대해 설명하세요. 
- 사용자가 'www.naver.com'을 입력하면 DNS를 통해 해당 도메인에 대한 IP 주소를 가지고 옵니다. URL 정보와 받아온 IP 주소를 통해 HTTP 요청 메세지를 생성하고, 요청 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환됩니다. 웹 서버에서는 도착한 웹 페이지 URL정보에 해당하는 데이터를 검색하여 HTTP 응답 메세지를 생성합니다. 이 HTTP 응답 메세지가 HTTP 프로토콜에 의해 사용자에게 네이버 화면으로 보여지게 됩니다.

 

 

 

세션 기반 인증과 토큰 기반 인증의 차이에 대해 설명하세요.
- 세션 기반 인증은 사용자 정보가 서버에 저장되기 때문에 Stateful한 특징을 가집니다. 반면에 토큰 기반 인증은 사용자 정보를 서버에 저장되지 않으므로 Stateless 한 특징을 가집니다.

 

 

세션 기반 인증과 토큰 기반 인증은 각각 어느 경우에 적합한가요?
- 단일 도메인이라면 세션 기반 인증을 사용하고, 아니라면 토큰 기반 인증을 사용하는 것이 적합하다고 생각합니다.

왜냐하면 세션을 사용할 때 이용되는 쿠키는 단일 도메인 및 서브 도메인에서만 작동하도록 설계가 되어 있기 때문에(= CORS 문제) 여러 도메인을 사용해야 한다면 토큰 기반 인증이 더 적합하다고 생각합니다.

 

 

CORS(Cross Origin Resource Sharing)에 대해 설명하세요.
- 출처(Origin)가 다를 때 보안상의 이유로 HTTP 요청을 제한하는데, CORS는 추가 HTTP 헤더를 사용하여, 현재 실행 중인 웹 애플리케이션이 아닌 다른 출처의 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 것입니다.

출처가 다르다는 것은 domainA.com에서 domainB.com의 자원을 요청하는 것으로 프론트단(=리액트)에서 서버(=스프링)로 HTTP 요청을 보낼 때 흔히 볼 수 있습니다.
 

 

JWT 토큰에 대해 설명하세요.
- JSON을 이용하는 웹 토큰으로 인증에 필요한 정보들을 암호화시킨 토큰입니다. 사용자 정보를 서버에 저장하는 것이 아니라 로그인 시 서버에서 클라이언트에게 유일한 토큰을 발급합니다. 이후 클라이언트는 JWT 토큰을 HTTP 헤더에 실어 서버가 클라이언트를 식별할 수 있게 하는 방식입니다.

 

 

Connection Timeout과 Read Timeout의 차이에 대해 설명하세요.
- Connection Timeout은 서버와 클라이언트 사이를 연결하는데 소요되는 최대 시간을 의미합니다. 만약 이 시간이 지나도록 연결이 안 되면 연결할 수 없는 것으로 판단하고 에러가 발생합니다.

Read Timeout은 연결된 후 데이터를 주고받을 때 소요되는 최대 시간을 의미합니다. 이 시간이 지나도록 데이터가 전송이 안되면 데이터를 받을 수 없는 것으로 판단하고 에러가 발생합니다.

 

 

공인 IP와 사설 IP의 차이에 대해 설명하세요.
- 공인 IP는 ISP(인터넷 서비스 공급자)가 제공하는 IP주소로, 유일한 주소이며 외부에 공개되어 있습니다.

사설 IP는 IPv4의 주소 부족으로 인해 서브넷팅된 IP주소로 사설 IP만으로는 인터넷에 직접 접속할 수 없고, 라우터를 통해서만 인터넷에 접속할 수 있습니다.

 

 

REST 및 REST API에 대해 설명하세요.
- REST란 자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 것입니다. HTTP URI을 통해 자원을 명시하고, HTTP 메소드인 GET, PUT, POST, DELETE 등을 통해 해당 자원에 대한 CRUD를 적용하는 것을 의미합니다.

이러한 REST를 기반으로 서비스 API를 구현한 것이 REST API입니다. 

 

 

RESTful에 대해 설명하세요.
- REST API의 설계 규칙을 따라 웹 서비스를 제공할 때 RESTful하다고 합니다. REST API 설계 규칙을 지키지 못한 대표적인 예는 모든 CRUD를 POST로 처리하는 API를 구현했거나 URI 규칙을 올바르게 지키지 않은 API는 RESTful하지 못한 시스템이라고 할 수 있습니다.

 

 

유니캐스트, 브로드캐스트, 멀티캐스트, 애니캐스트에 대해 설명하세요.
- 유니캐스트는 송신 측과 수신 측이 1:1인 경우의 통신을 의미합니다. 브로드캐스트는 같은 네트워크 안에 있는 모든 장비들에게 데이터 전송하는 것을 의미합니다. 멀티캐스트는 여러 개의 장비에게 데이터를 전송하지만 브로드캐스트처럼 모든 장비가 아닌 특정 장비만 지정해서 보내는 방식입니다. 애니캐스트는 네트워크에 연결된 수신 가능한 장비 중 가장 가까운 장비와 통신하는 방식입니다.

 

 

API GATEWAY
- 외부에서 들어오는 모든 API 요청의 관문(Gateway) 역할을 하는 서버로, 클라이언트가 시스템의 아키텍처를 몰라도 약속된 형태의 API 요청만 보내면 적절한 형태로 응답해주는 서버입니다. 장점으로는 클라이언트의 요청을 일괄적으로 처리하고, 전체 시스템의 부하를 분산시키틑 로드 밸런서의 역할을 수행합니다.